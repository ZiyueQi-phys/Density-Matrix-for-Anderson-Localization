from scipy.sparse.linalg import eigsh
import os
from numpy import conj
from math import *
import cmath
import matplotlib.cm as cm
import scipy.sparse
from scipy.sparse import csr_matrix
from scipy.sparse.linalg import eigs, eigsh
import time
from scipy.optimize import curve_fit
import numpy as np
import matplotlib.pyplot as plt

def custom_func(x, a, b, c, xi):
    #return a*np.exp(-b*x)
    return a*np.sin((b)*(x))/(x**1)*np.exp(-x/xi)


def custom_func_single(x, a, b):
    return a*np.exp(-b*x)
    return a*np.sin((b)*(x))/(x**1)*np.exp(-x/xi)


current_path = os.getcwd()

len_list = 20
num_L = 3



num_iter = 20

num_times = 5


C_final_list_sample = np.zeros((len_list, num_times), dtype=float)

local_length_real_list = []


for ss in range(num_times):
    L_list = np.array([ii+1 for ii in range(len_list)], dtype=float)
    C_list_single = np.zeros((num_L,num_L,len_list),dtype=float)
    for ii in range(ss*20,num_iter+ss*20):
        #if( ii==80 or ii==87  ):
        #    continue
        path = file_path = os.path.join(current_path, str(ii) , 'out')
        with open(path, 'r') as phase:
        #with open('E:\\DFT_calculation\\wannier_tools\\KIn\\sigma_ahc_eta10.00meV.txt', 'r') as phase:

            orbital_value = phase.readlines()
        phase.close()
        for jj in range(len(orbital_value)):
            
            orbital_value[jj] = orbital_value[jj].split()
            if( abs(len(orbital_value)-jj) <= num_L*num_L*len_list ):
                #print(orbital_value[jj])
                string_temp = orbital_value[jj]
                x = int(float(string_temp[0])) - 1
                y = int(float(string_temp[1])) - 1
                z = int(float(string_temp[2])) - 1
                data = float(string_temp[3])

                C_list_single[x,y,z] = C_list_single[x,y,z] + data/num_iter/2

    R_list = np.array([ii+1 for ii in range(len_list)])
    C_final_list = []

    print("C_list:")
    for kk in range(len_list):
        for ii in range(num_L):
            for jj in range(num_L):
                1#print(ii,jj,kk,C_list_single[ii,jj,kk])

    for ii in range(len_list):
        C_temp = C_list_single[:,:,ii]
        e,v = np.linalg.eigh(np.dot(C_temp,C_temp.transpose()))

        C_final_list.append((np.max(e)))
        
    a4, b4= curve_fit(custom_func_single, R_list, np.array(C_final_list))[0]
    x4 = np.arange(1,len_list, 0.01)
    y4 = a4*np.exp(-b4*x4)
    print(a4, 1/b4)
    C_final_list = np.array(C_final_list)

    C_final_list_sample[:,ss] = C_final_list[:]

    # 绘制自相关函数和拟合结果
    color_list = ['r','k','b','m','pink','orange']
    plt.figure(figsize=(8, 6))
    plt.scatter(R_list, C_final_list, color='red',label='max')
    #plt.scatter(R_list, C_final_list_svd,color='b',label='svd')
    plt.plot(x4, y4, '--', label=f'Fit: ξ = {1/b4:.2f}')
    plt.xlabel('Distance r')
    plt.ylabel('C(r)')
    plt.legend(prop = {'size':16})
    plt.title('Localization Length from Green\'s Function')
    plt.savefig('single_corr_2D_' + str(ss) + '.pdf')
    print(len(C_final_list))
    print("C_list-final:",[C_final_list[ii] for ii in range(len(C_final_list)) ] )

    local_length_real_list.append(1/b4)


C_final_average = np.zeros((len_list),dtype=float)
C_final_error = np.zeros((len_list),dtype=float)

for ii in range(len_list):
    C_final_average[ii] = np.mean(C_final_list_sample[ii,:])
    C_final_error[ii] = np.std(C_final_list_sample[ii,:])



color_list = ['r','k','b','m','pink','orange']

fig = plt.figure(figsize=(4.5,4.5))
sub = fig.add_subplot(111)
plt.tick_params(size=8,width=1.5,labelsize = 12)
sub.spines['bottom'].set_linewidth(1.6)
sub.spines['left'].set_linewidth(1.6)
sub.spines['right'].set_linewidth(1.6)
sub.spines['top'].set_linewidth(1.6)

sub.spines['bottom'].set_color('black')
sub.spines['top'].set_color('black')
sub.spines['right'].set_color('black')
sub.spines['left'].set_color('black')


R_list = np.array([ii+1 for ii in range(len_list)])
plt.plot(R_list, C_final_average ,color=color_list[0], linewidth = 2)
plt.errorbar( R_list, C_final_average, yerr=C_final_error, fmt='o', color=color_list[0], ecolor=color_list[0], capsize=5, label='C(r)' )


plt.legend(prop={'size':12})

#plt.yticks([4,5,6,7])
#plt.ylim(top=4.5)
plt.ticklabel_format(style='sci', axis='y', scilimits=(0, 0))
plt.savefig('statistic_Cr.svg')





num_gauss = 5

local_length_list = np.zeros((num_gauss),dtype=float)

for ss in range(num_gauss):
    C_final_gauss = np.zeros((len_list),dtype=float)
    
    for ii in range(len_list):
        random_numbers = np.random.normal(C_final_average[ii], C_final_error[ii], 10)
        C_final_gauss[ii] = np.mean(random_numbers)

    R_list = np.array([ii+1 for ii in range(len_list)])

    a4, b4= curve_fit(custom_func_single, R_list, np.array(C_final_gauss))[0]
    x4 = np.arange(1,len_list, 0.01)
    y4 = a4*np.exp(-b4*x4)
    print(a4, 1/b4)
    

    color_list = ['r','k','b','m','pink','orange']
    plt.figure(figsize=(8, 6))
    plt.scatter(R_list, C_final_gauss, color='red',label='max')
    #plt.scatter(R_list, C_final_list_svd,color='b',label='svd')
    plt.plot(x4, y4, '--', label=f'Fit: ξ = {1/b4:.2f}')
    plt.xlabel('Distance r')
    plt.ylabel('C(r)')
    plt.legend(prop = {'size':16})
    plt.title('Localization Length from Green\'s Function')
    plt.savefig('gaussian_corr_2D_' + str(ss) + '.pdf')

    local_length_list[ss] = 1/b4

print("gaussian_mean_localization_length:", np.mean(local_length_list))
print("gaussian_std_localization_length:", np.std(local_length_list))


print("local_length_real_list:",np.std(np.array(local_length_real_list)), np.mean(np.array(local_length_real_list)))
print(local_length_real_list)

